/*
*Programmer: Manpreet Sandhu
*
*/
#include<stdio.h>
#include<stdlib.h>
#define size 7

/* A Binary Tree node */
struct TNode {
	int data;
	struct TNode* left;
	struct TNode* right;
};

struct TNode* newNode(int data);
/* Shell Sort Methods */
/* function to sort arr using shellSort */

int shellSort(int arr[size], int n) {
	
	// Start with a big gap, then reduce the gap
	for (int gap = n/2; gap > 0; gap /= 2) {
		// Do a gapped insertion sort for this gap size.
		// The first gap elements a[0..gap-1] are already in gapped order
		// keep adding one more element until the entire array is
		// gap sorted
		for (int i = gap; i < n; i += 1) {
			// add a[i] to the elements that have been gap sorted
			// save a[i] in temp and make a hole at position i
			int temp = arr[i];

			// shift earlier gap-sorted elements up until the correct
			// location for a[i] is found
			int j;
			for (j = i; j >= gap && arr[j - gap] > temp; j -= gap)
				arr[j] = arr[j - gap];

			//  put temp (the original a[i]) in its correct location
			arr[j] = temp;
		}
	}
	return 0;
}

/* A function that constructs Balanced Binary Search Tree from a sorted array */
struct TNode* rootInsert(int arr[], int start, int end) {
	/* Base Case */
	if (start > end)
		return NULL;

	/* Get the middle element and make it root */
	int midValue = (start+end)/2;
	struct TNode *root = newNode(arr[midValue]);

	/* Recursively construct the left subtree and make it
	   left child of root */
	root->left =  rootInsert(arr, start, midValue-1);

	/* Recursively construct the right subtree and make it
	   right child of root */
	root->right = rootInsert(arr, midValue+1, end);

	return root;
}

/* Helper function that allocates a new node with the
   given data and NULL left and right pointers. */
struct TNode* newNode(int data) {
	
	struct TNode* node = (struct TNode*)
	                     malloc(sizeof(struct TNode));
	node->data = data;
	node->left = NULL;
	node->right = NULL;

	return node;
}

/* Given a binary tree, print its nodes in inorder*/
void inorder(struct TNode *t)
{
  if(t!=NULL)
  {
    inorder(t->left);
    printf("%d\n",t->data);
    inorder(t->right);
  }
}

/* main method*/
int main(int argv, char** argc) {

	int a[size];//array of size  = 7
	int n = sizeof(a)/sizeof(int); 

	for (int i = 0; i < size; i++) {

		a[i] = rand();
	}
	
	//printing unsorted elements of the array
	printf("UnSorted Elements generated by random function:\n");
	for(int i=0; i<size; i++) {

		printf("%d\n",a[i]);
		
	}

    /* invoke the shellSort method */
	shellSort(a,size);
	
	//printing the Sorted elements of the array
	printf("-----------------------------------------\n");
	printf("Sorted Elements using Shell Sort:\n");
	for(int i=0; i<size; i++) {

		printf("%d\n",a[i]);
	}
    
    printf("------------------------------------------\n");

	/* Convert List to BST */
	struct TNode *root = rootInsert(a, 0,size-1);
	printf("InOrder Traversal of constructed BST:\n ");
	printf("\n");
	
	/*invoke the inorder method*/
	inorder(root);
	
	//printing the root element in the array
	printf("\n");
	printf("The Root element is: %d",a[n/2]);

	return 0;
}
